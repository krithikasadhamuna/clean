#!/usr/bin/env python3
"""
Creative Attack Planner
AI creates ANY attack scenario from natural language - NO HARDCODING
Uses GPT-3.5-turbo to understand requests and plan sophisticated attacks
"""

import logging
import json
import asyncio
import requests
from typing import Dict, List, Any, Optional
from datetime import datetime
from dataclasses import dataclass, asdict
import uuid

from .intelligent_endpoint_analyzer import endpoint_analyzer

logger = logging.getLogger(__name__)


@dataclass
class AttackPhase:
    """Single phase of an attack"""
    name: str
    description: str
    target_endpoints: List[str]
    commands: List[Dict[str, Any]]
    techniques: List[str]
    duration_estimate: str
    success_criteria: List[str]


@dataclass
class AttackPlan:
    """Complete attack plan generated by AI"""
    plan_id: str
    name: str
    description: str
    attack_type: str
    objective: str
    phases: List[AttackPhase]
    required_infrastructure: Dict[str, List[str]]
    target_endpoints: List[str]
    estimated_duration: str
    risk_level: str
    mitre_techniques: List[str]
    generated_at: str
    confidence_score: float


class CreativeAttackPlanner:
    """
    AI creates ANY attack scenario - NO HARDCODING
    Uses GPT-3.5-turbo/Ollama to understand natural language and plan attacks
    """
    
    def __init__(self, llm_config: Dict = None):
        self.llm_config = llm_config or self._default_llm_config()
        self.endpoint_analyzer = endpoint_analyzer
        
    def _default_llm_config(self) -> Dict:
        """Load LLM configuration"""
        try:
            from shared.config import config
            server_config = config.load_server_config()
            return server_config.get('llm', {
                'provider': 'openai',
                'model': 'gpt-3.5-turbo',
                'ollama_endpoint': 'http://localhost:11434',
                'ollama_model': 'cybersec-ai'
            })
        except:
            return {
                'provider': 'openai',
                'model': 'gpt-3.5-turbo',
                'ollama_endpoint': 'http://localhost:11434',
                'ollama_model': 'cybersec-ai'
            }
    
    async def plan_custom_attack(self, attack_request: str, endpoints: List[Dict]) -> AttackPlan:
        """
        AI plans ANY attack from natural language request
        
        Examples:
        - "Spear phish the CEO"
        - "Ransomware targeting file servers"
        - "Insider threat stealing database"
        - "Supply chain attack via dev server"
        - "APT29 style attack with lateral movement"
        
        Args:
            attack_request: Natural language attack request
            endpoints: Available network endpoints
        
        Returns:
            Complete attack plan with phases and commands
        """
        try:
            logger.info(f"Planning custom attack: {attack_request[:100]}...")
            
            # Step 1: Analyze available resources
            resources = await self._analyze_available_resources(endpoints)
            
            # Step 2: Use AI to understand attack intent
            attack_intent = await self._parse_attack_intent_with_ai(attack_request, resources)
            
            # Step 3: Check for missing infrastructure and plan to create it
            infrastructure_plan = await self._plan_infrastructure_deployment(attack_intent, resources)
            
            # Step 4: Use AI to generate complete attack plan
            attack_plan = await self._generate_attack_plan_with_ai(
                attack_request, attack_intent, resources, infrastructure_plan
            )
            
            # Step 5: Validate and enrich the plan
            validated_plan = await self._validate_and_enrich_plan(attack_plan, endpoints)
            
            logger.info(f"Generated attack plan: {validated_plan.name} with {len(validated_plan.phases)} phases")
            return validated_plan
            
        except Exception as e:
            logger.error(f"Attack planning failed: {e}")
            # Return a basic fallback plan
            return await self._create_fallback_plan(attack_request, endpoints)
    
    async def _analyze_available_resources(self, endpoints: List[Dict]) -> Dict[str, Any]:
        """Analyze what resources are available in the network"""
        try:
            resources = {
                'total_endpoints': len(endpoints),
                'executives': [],
                'admins': [],
                'smtp_servers': [],
                'ftp_servers': [],
                'web_servers': [],
                'database_servers': [],
                'domain_controllers': [],
                'entry_points': [],
                'high_value_targets': [],
                'by_platform': {'windows': [], 'linux': [], 'macos': []},
                'by_zone': {}
            }
            
            # Analyze each endpoint
            for endpoint in endpoints:
                analysis = await self.endpoint_analyzer.analyze_endpoint_capabilities(endpoint)
                endpoint_with_analysis = {**endpoint, 'analysis': analysis}
                
                # Categorize by role
                if analysis['is_executive']:
                    resources['executives'].append(endpoint_with_analysis)
                if analysis['is_admin']:
                    resources['admins'].append(endpoint_with_analysis)
                if analysis['can_be_smtp']:
                    resources['smtp_servers'].append(endpoint_with_analysis)
                if analysis['can_be_ftp']:
                    resources['ftp_servers'].append(endpoint_with_analysis)
                if analysis['can_be_web_server']:
                    resources['web_servers'].append(endpoint_with_analysis)
                if analysis['can_be_database']:
                    resources['database_servers'].append(endpoint_with_analysis)
                if analysis['is_domain_controller']:
                    resources['domain_controllers'].append(endpoint_with_analysis)
                
                # High-value targets
                if analysis['value_score'] > 60:
                    resources['high_value_targets'].append(endpoint_with_analysis)
                
                # Entry points
                if analysis['attack_surface_score'] > 50:
                    resources['entry_points'].append(endpoint_with_analysis)
                
                # Categorize by platform
                platform = endpoint.get('platform', '').lower()
                if 'windows' in platform:
                    resources['by_platform']['windows'].append(endpoint_with_analysis)
                elif 'linux' in platform:
                    resources['by_platform']['linux'].append(endpoint_with_analysis)
                elif 'mac' in platform:
                    resources['by_platform']['macos'].append(endpoint_with_analysis)
                
                # Categorize by zone
                zone = endpoint.get('security_zone', 'unknown')
                if zone not in resources['by_zone']:
                    resources['by_zone'][zone] = []
                resources['by_zone'][zone].append(endpoint_with_analysis)
            
            logger.info(f"Resource analysis: {len(resources['executives'])} executives, "
                       f"{len(resources['smtp_servers'])} SMTP servers, "
                       f"{len(resources['high_value_targets'])} HVTs")
            
            return resources
            
        except Exception as e:
            logger.error(f"Resource analysis failed: {e}")
            return {'total_endpoints': len(endpoints)}
    
    async def _parse_attack_intent_with_ai(self, attack_request: str, resources: Dict) -> Dict[str, Any]:
        """Use AI to understand attack intent from natural language"""
        try:
            # Create AI prompt
            prompt = f"""You are a red team expert analyzing an attack request.

ATTACK REQUEST: "{attack_request}"

AVAILABLE RESOURCES:
- Total Endpoints: {resources.get('total_endpoints', 0)}
- Executive Endpoints: {len(resources.get('executives', []))}
- Admin Endpoints: {len(resources.get('admins', []))}
- SMTP Servers: {len(resources.get('smtp_servers', []))}
- FTP Servers: {len(resources.get('ftp_servers', []))}
- Web Servers: {len(resources.get('web_servers', []))}
- Database Servers: {len(resources.get('database_servers', []))}
- Domain Controllers: {len(resources.get('domain_controllers', []))}

Analyze the request and return JSON with:
{{
    "attack_type": "spear_phishing|ransomware|lateral_movement|data_exfiltration|insider_threat|supply_chain|apt|custom",
    "primary_objective": "brief description of main goal",
    "target_types": ["executive", "admin", "database", "domain_controller"],
    "required_infrastructure": ["smtp", "ftp", "web_server"],
    "attack_techniques": ["T1566.001", "T1055"],
    "stealth_level": "loud|moderate|stealthy",
    "complexity": "simple|intermediate|advanced|expert",
    "estimated_phases": 3
}}

Be creative and specific based on the request.
"""
            
            # Call AI
            ai_response = await self._call_ai(prompt)
            
            try:
                intent = json.loads(ai_response)
                logger.info(f"AI parsed intent: {intent.get('attack_type', 'unknown')}")
                return intent
            except json.JSONDecodeError:
                logger.warning("AI response not valid JSON, using keyword parsing")
                return self._fallback_intent_parsing(attack_request)
                
        except Exception as e:
            logger.error(f"AI intent parsing failed: {e}")
            return self._fallback_intent_parsing(attack_request)
    
    def _fallback_intent_parsing(self, attack_request: str) -> Dict[str, Any]:
        """Fallback keyword-based intent parsing"""
        request_lower = attack_request.lower()
        
        # Detect attack type
        if any(term in request_lower for term in ['phish', 'email', 'spear']):
            attack_type = 'spear_phishing'
        elif any(term in request_lower for term in ['ransom', 'encrypt', 'crypto']):
            attack_type = 'ransomware'
        elif any(term in request_lower for term in ['lateral', 'move', 'pivot']):
            attack_type = 'lateral_movement'
        elif any(term in request_lower for term in ['exfil', 'steal', 'data']):
            attack_type = 'data_exfiltration'
        elif any(term in request_lower for term in ['insider', 'employee']):
            attack_type = 'insider_threat'
        elif any(term in request_lower for term in ['apt', 'advanced', 'persistent']):
            attack_type = 'apt'
        else:
            attack_type = 'custom'
        
        return {
            'attack_type': attack_type,
            'primary_objective': attack_request[:200],
            'target_types': ['high_value'],
            'required_infrastructure': [],
            'attack_techniques': [],
            'stealth_level': 'moderate',
            'complexity': 'intermediate',
            'estimated_phases': 3
        }
    
    async def _plan_infrastructure_deployment(self, attack_intent: Dict, resources: Dict) -> Dict[str, Any]:
        """Plan infrastructure deployment for missing resources"""
        infrastructure_plan = {
            'missing_resources': [],
            'deployment_commands': []
        }
        
        required = attack_intent.get('required_infrastructure', [])
        
        # Check for SMTP
        if 'smtp' in required and not resources.get('smtp_servers'):
            candidates = await self.endpoint_analyzer.find_attack_infrastructure_candidates(
                resources.get('by_platform', {}).get('linux', []) + 
                resources.get('by_platform', {}).get('windows', []),
                'smtp'
            )
            if candidates:
                infrastructure_plan['missing_resources'].append('smtp')
                infrastructure_plan['deployment_commands'].append({
                    'resource': 'smtp',
                    'endpoint_id': candidates[0]['id'],
                    'command_type': 'deploy_smtp_container'
                })
        
        # Check for FTP
        if 'ftp' in required and not resources.get('ftp_servers'):
            candidates = await self.endpoint_analyzer.find_attack_infrastructure_candidates(
                resources.get('by_platform', {}).get('linux', []),
                'ftp'
            )
            if candidates:
                infrastructure_plan['missing_resources'].append('ftp')
                infrastructure_plan['deployment_commands'].append({
                    'resource': 'ftp',
                    'endpoint_id': candidates[0]['id'],
                    'command_type': 'deploy_ftp_container'
                })
        
        # Check for Web Server
        if 'web_server' in required and not resources.get('web_servers'):
            candidates = await self.endpoint_analyzer.find_attack_infrastructure_candidates(
                resources.get('by_platform', {}).get('linux', []),
                'web_server'
            )
            if candidates:
                infrastructure_plan['missing_resources'].append('web_server')
                infrastructure_plan['deployment_commands'].append({
                    'resource': 'web_server',
                    'endpoint_id': candidates[0]['id'],
                    'command_type': 'deploy_web_server_container'
                })
        
        if infrastructure_plan['missing_resources']:
            logger.info(f"Will deploy missing infrastructure: {infrastructure_plan['missing_resources']}")
        
        return infrastructure_plan
    
    async def _generate_attack_plan_with_ai(self, attack_request: str, attack_intent: Dict,
                                           resources: Dict, infrastructure_plan: Dict) -> AttackPlan:
        """Use AI to generate complete attack plan"""
        try:
            # Create detailed prompt for AI
            prompt = f"""You are PhantomStrike AI, an elite red team attack planner.

ATTACK REQUEST: "{attack_request}"

ATTACK INTENT:
{json.dumps(attack_intent, indent=2)}

AVAILABLE RESOURCES:
{json.dumps({
    'executives': len(resources.get('executives', [])),
    'smtp_servers': len(resources.get('smtp_servers', [])),
    'database_servers': len(resources.get('database_servers', [])),
    'domain_controllers': len(resources.get('domain_controllers', [])),
    'high_value_targets': len(resources.get('high_value_targets', []))
}, indent=2)}

INFRASTRUCTURE DEPLOYMENT PLAN:
{json.dumps(infrastructure_plan, indent=2)}

Generate a complete attack plan with JSON format:
{{
    "name": "Descriptive attack scenario name",
    "description": "Detailed description of the attack",
    "attack_type": "{attack_intent.get('attack_type', 'custom')}",
    "objective": "What we're trying to accomplish",
    "phases": [
        {{
            "name": "Phase 1: Infrastructure Setup",
            "description": "Deploy missing infrastructure",
            "target_endpoints": ["endpoint_ids"],
            "commands": [
                {{
                    "command_type": "deploy_smtp_container",
                    "endpoint_id": "endpoint_1",
                    "purpose": "SMTP for phishing"
                }}
            ],
            "techniques": ["T1xxx"],
            "duration_estimate": "10 minutes",
            "success_criteria": ["SMTP server running"]
        }},
        {{
            "name": "Phase 2: Target Preparation",
            "description": "Create target replicas",
            "target_endpoints": ["executive_endpoints"],
            "commands": [
                {{
                    "command_type": "create_self_replica",
                    "endpoint_id": "executive_1",
                    "purpose": "Executive target for phishing"
                }}
            ],
            "techniques": ["T1xxx"],
            "duration_estimate": "15 minutes",
            "success_criteria": ["Target replicas created"]
        }},
        {{
            "name": "Phase 3: Attack Execution",
            "description": "Execute the attack",
            "target_endpoints": ["all_involved"],
            "commands": [
                {{
                    "command_type": "execute_phishing",
                    "endpoint_id": "smtp_server",
                    "data": {{
                        "from": "smtp_container",
                        "to": ["executive_1_replica"],
                        "technique": "T1566.001"
                    }}
                }}
            ],
            "techniques": ["T1566.001"],
            "duration_estimate": "20 minutes",
            "success_criteria": ["Attack executed", "Logs generated"]
        }}
    ],
    "estimated_duration": "45 minutes",
    "risk_level": "medium",
    "mitre_techniques": ["T1566.001", "T1059.001"]
}}

Be creative, specific, and realistic. Consider:
1. Available resources and what's missing
2. Proper attack sequence
3. Container deployment for safety
4. Real MITRE ATT&CK techniques
5. Realistic timing
"""
            
            # Call AI
            ai_response = await self._call_ai(prompt)
            
            try:
                plan_data = json.loads(ai_response)
                
                # Convert to AttackPlan object
                phases = []
                for phase_data in plan_data.get('phases', []):
                    phase = AttackPhase(
                        name=phase_data['name'],
                        description=phase_data['description'],
                        target_endpoints=phase_data['target_endpoints'],
                        commands=phase_data['commands'],
                        techniques=phase_data['techniques'],
                        duration_estimate=phase_data['duration_estimate'],
                        success_criteria=phase_data['success_criteria']
                    )
                    phases.append(phase)
                
                attack_plan = AttackPlan(
                    plan_id=f"plan_{uuid.uuid4().hex[:8]}",
                    name=plan_data['name'],
                    description=plan_data['description'],
                    attack_type=plan_data['attack_type'],
                    objective=plan_data['objective'],
                    phases=phases,
                    required_infrastructure=infrastructure_plan,
                    target_endpoints=self._extract_all_target_endpoints(phases),
                    estimated_duration=plan_data['estimated_duration'],
                    risk_level=plan_data['risk_level'],
                    mitre_techniques=plan_data['mitre_techniques'],
                    generated_at=datetime.utcnow().isoformat(),
                    confidence_score=0.9
                )
                
                return attack_plan
                
            except json.JSONDecodeError:
                logger.warning("AI plan not valid JSON, creating structured plan")
                return await self._create_structured_plan(attack_intent, resources, infrastructure_plan)
                
        except Exception as e:
            logger.error(f"AI plan generation failed: {e}")
            return await self._create_structured_plan(attack_intent, resources, infrastructure_plan)
    
    async def _create_structured_plan(self, attack_intent: Dict, resources: Dict, 
                                     infrastructure_plan: Dict) -> AttackPlan:
        """Create structured attack plan when AI fails"""
        phases = []
        
        # Phase 1: Infrastructure (if needed)
        if infrastructure_plan['deployment_commands']:
            infra_commands = []
            for deploy_cmd in infrastructure_plan['deployment_commands']:
                infra_commands.append({
                    'command_type': deploy_cmd['command_type'],
                    'endpoint_id': deploy_cmd['endpoint_id'],
                    'purpose': f"Deploy {deploy_cmd['resource']} server"
                })
            
            phases.append(AttackPhase(
                name="Infrastructure Deployment",
                description="Deploy required attack infrastructure",
                target_endpoints=[cmd['endpoint_id'] for cmd in infra_commands],
                commands=infra_commands,
                techniques=["T1608.001"],
                duration_estimate="10 minutes",
                success_criteria=["Infrastructure deployed"]
            ))
        
        # Phase 2: Target Preparation
        target_commands = []
        targets = resources.get('executives', []) or resources.get('high_value_targets', [])
        for target in targets[:3]:  # Limit to 3 targets
            target_commands.append({
                'command_type': 'create_self_replica',
                'endpoint_id': target['id'],
                'purpose': 'Create target replica'
            })
        
        if target_commands:
            phases.append(AttackPhase(
                name="Target Preparation",
                description="Create replicas of target systems",
                target_endpoints=[cmd['endpoint_id'] for cmd in target_commands],
                commands=target_commands,
                techniques=["T1610"],
                duration_estimate="15 minutes",
                success_criteria=["Target replicas created"]
            ))
        
        # Phase 3: Attack Execution
        attack_type = attack_intent.get('attack_type', 'custom')
        exec_commands = self._generate_execution_commands(attack_type, resources, targets[:3])
        
        if exec_commands:
            phases.append(AttackPhase(
                name="Attack Execution",
                description=f"Execute {attack_type} attack",
                target_endpoints=[cmd['endpoint_id'] for cmd in exec_commands],
                commands=exec_commands,
                techniques=self._get_techniques_for_attack_type(attack_type),
                duration_estimate="20 minutes",
                success_criteria=["Attack executed", "Logs collected"]
            ))
        
        return AttackPlan(
            plan_id=f"plan_{uuid.uuid4().hex[:8]}",
            name=f"{attack_type.replace('_', ' ').title()} Attack Scenario",
            description=f"Structured {attack_type} attack plan",
            attack_type=attack_type,
            objective=attack_intent.get('primary_objective', 'Execute attack'),
            phases=phases,
            required_infrastructure=infrastructure_plan,
            target_endpoints=self._extract_all_target_endpoints(phases),
            estimated_duration="45 minutes",
            risk_level="medium",
            mitre_techniques=self._get_techniques_for_attack_type(attack_type),
            generated_at=datetime.utcnow().isoformat(),
            confidence_score=0.7
        )
    
    def _generate_execution_commands(self, attack_type: str, resources: Dict, 
                                    targets: List[Dict]) -> List[Dict]:
        """Generate execution commands based on attack type"""
        commands = []
        
        if attack_type == 'spear_phishing':
            smtp_servers = resources.get('smtp_servers', [])
            if smtp_servers and targets:
                commands.append({
                    'command_type': 'execute_phishing',
                    'endpoint_id': smtp_servers[0]['id'],
                    'data': {
                        'from': 'smtp_container',
                        'to': [f"{t['id']}_replica" for t in targets],
                        'technique': 'T1566.001'
                    }
                })
        
        elif attack_type == 'lateral_movement':
            entry_points = resources.get('entry_points', [])
            if entry_points and targets:
                commands.append({
                    'command_type': 'execute_lateral_movement',
                    'endpoint_id': entry_points[0]['id'],
                    'data': {
                        'source': entry_points[0]['id'],
                        'targets': [t['id'] for t in targets],
                        'technique': 'T1021.001'
                    }
                })
        
        elif attack_type == 'data_exfiltration':
            databases = resources.get('database_servers', [])
            if databases:
                commands.append({
                    'command_type': 'execute_data_exfiltration',
                    'endpoint_id': databases[0]['id'],
                    'data': {
                        'source': databases[0]['id'],
                        'data_types': ['credentials', 'sensitive_data'],
                        'technique': 'T1041'
                    }
                })
        
        return commands
    
    def _get_techniques_for_attack_type(self, attack_type: str) -> List[str]:
        """Get MITRE techniques for attack type"""
        technique_map = {
            'spear_phishing': ['T1566.001', 'T1059.001'],
            'ransomware': ['T1486', 'T1490', 'T1491'],
            'lateral_movement': ['T1021.001', 'T1021.002', 'T1550'],
            'data_exfiltration': ['T1041', 'T1048', 'T1020'],
            'insider_threat': ['T1078', 'T1003', 'T1005'],
            'apt': ['T1566.001', 'T1055', 'T1003', 'T1021.001']
        }
        return technique_map.get(attack_type, ['T1082', 'T1059.001'])
    
    def _extract_all_target_endpoints(self, phases: List[AttackPhase]) -> List[str]:
        """Extract all target endpoint IDs from phases"""
        all_targets = set()
        for phase in phases:
            all_targets.update(phase.target_endpoints)
        return list(all_targets)
    
    async def _validate_and_enrich_plan(self, attack_plan: AttackPlan, 
                                       endpoints: List[Dict]) -> AttackPlan:
        """Validate attack plan against real network"""
        # Validate target endpoints exist
        valid_endpoint_ids = {e['id'] for e in endpoints}
        attack_plan.target_endpoints = [
            e for e in attack_plan.target_endpoints if e in valid_endpoint_ids
        ]
        
        # If no valid targets, use available endpoints
        if not attack_plan.target_endpoints and endpoints:
            attack_plan.target_endpoints = [endpoints[0]['id']]
        
        return attack_plan
    
    async def _create_fallback_plan(self, attack_request: str, endpoints: List[Dict]) -> AttackPlan:
        """Create basic fallback plan"""
        return AttackPlan(
            plan_id=f"fallback_{uuid.uuid4().hex[:8]}",
            name="Basic Attack Scenario",
            description=f"Basic plan for: {attack_request}",
            attack_type="custom",
            objective=attack_request[:200],
            phases=[],
            required_infrastructure={},
            target_endpoints=[endpoints[0]['id']] if endpoints else [],
            estimated_duration="30 minutes",
            risk_level="low",
            mitre_techniques=["T1082"],
            generated_at=datetime.utcnow().isoformat(),
            confidence_score=0.5
        )
    
    async def _call_ai(self, prompt: str) -> str:
        """Call AI (GPT-3.5-turbo or Ollama)"""
        try:
            # Try OpenAI first
            provider = self.llm_config.get('provider', 'openai')
            
            if provider == 'openai':
                from langchain_openai import ChatOpenAI
                llm = ChatOpenAI(
                    model=self.llm_config.get('model', 'gpt-3.5-turbo'),
                    temperature=0.7
                )
                response = await llm.ainvoke(prompt)
                return response.content
            
            # Fallback to Ollama
            elif provider == 'ollama':
                endpoint = self.llm_config.get('ollama_endpoint', 'http://localhost:11434')
                model = self.llm_config.get('ollama_model', 'cybersec-ai')
                
                response = requests.post(
                    f"{endpoint}/api/generate",
                    json={
                        'model': model,
                        'prompt': prompt,
                        'stream': False
                    },
                    timeout=60
                )
                
                if response.status_code == 200:
                    return response.json().get('response', '')
            
            return ""
            
        except Exception as e:
            logger.error(f"AI call failed: {e}")
            return ""


# Global instance
creative_planner = CreativeAttackPlanner()

